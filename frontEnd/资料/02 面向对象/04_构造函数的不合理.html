<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

  <script>
    /*
      构造函数的不合理
        + 当你在构造函数体内书写方法的时候
          => 你需要向对象上添加方法的时候
          => 只要创建一次对象(new 一次) 就会有一个函数在占用空间
          => 创建 100 次对象, 会有 100 个一模一样的函数出现
        + 100 个函数一模一样
          => 但是其实里面有 99 个是重复的, 没有必要存在
    */

    // 1. 准备一个构造函数
    function Person(name, age) {
      this.name = name
      this.age = age
      this.sayHi = function () { console.log('hello world') }
    }

    // 2. 创建对象
    var p1 = new Person('Jack', 18)
    var p2 = new Person('Rose', 20)

    console.log(p1, p2)
    // 调用两个对象的 sayHi 方法
    p1.sayHi()
    p2.sayHi()
    // 看一下是不是真的是两个对象
    console.log(p1 == p2) // false, 确实是两个对象

    // 两个对象里面的函数
    console.log(p1.sayHi)
    console.log(p2.sayHi)
    console.log(p1.sayHi == p2.sayHi) // false, 是两个函数


    /*
      var p1 = new Person('Jack', 18)
      var p2 = new Person('Rose', 20)

      p1 第一次执行 Person 函数
        => 会吧函数内部的 this 指向 p1
        => 会吧函数体内的代码全部执行一遍
        => 向 p1 上添加 name 属性
        => 向 p1 上添加 age 属性
        => 向 p1 上添加 sayHi 方法, 会创建一个函数出来

      p2 第二次执行 Person 函数
        => 会吧函数内部的 this 指向 p2
        => 会吧函数体内的代码全部执行一遍
        => 向 p2 上添加 name 属性
        => 向 p2 上添加 age 属性
        => 向 p2 上添加 sayHi 方法, 会创建一个函数出来
    */
  </script>
</body>
</html>
